--RP the application installation should do this for you in the Supporting Objects...

CREATE OR REPLACE PACKAGE "BIP2FOP_PKG" as
   
function clob2blob(AClob CLOB) return BLOB;
FUNCTION blob2clob (i_blob IN BLOB) RETURN CLOB;
procedure convert_fo_template(p in out nocopy clob);

function convert_fo_template(xml_in clob, fix_urlencode in varchar2 default 'no') return clob;

end;
/


CREATE OR REPLACE PACKAGE BODY "BIP2FOP_PKG" is

function convert_fo_template(xml_in clob, fix_urlencode in VARCHAR2 default 'no') return clob is
  l_xslfo clob;
  l_xsl_urlencodefix clob;
  l_xml_out clob;

BEGIN
  l_xslfo := '<!-- do not forget to include all the namespaces that we want to work with from the xslt that we are transforming. -->
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xmlns:xdofo="http://xmlns.oracle.com/oxp/fo/extensions" 
 xmlns:fo="http://www.w3.org/1999/XSL/Format" 
 xmlns:ora="http://www.oracle.com/XSL/Transform/java/" 
 xmlns:xdoxslt="http://www.oracle.com/XSL/Transform/java/oracle.xdo.template.rtf.XSLTFunctions" 
>
    
<!-- identity transform, which copies everything forward -->
<xsl:template match="@*|node()">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()"/>
  </xsl:copy>
</xsl:template>

<!--XSLT 1.0 does not have a replace function -->
<xsl:template name="replace-string">
 <xsl:param name="text"/>
 <xsl:param name="replace"/>
 <xsl:param name="with"/>
 <xsl:choose>
  <xsl:when test="$replace and contains($text,$replace)">
   <xsl:value-of select="substring-before($text,$replace)"/>
   <xsl:value-of select="$with"/>
   <xsl:call-template name="replace-string">
    <xsl:with-param name="text" select="substring-after($text,$replace)"/>
    <xsl:with-param name="replace" select="$replace"/>
    <xsl:with-param name="with" select="$with"/>
   </xsl:call-template>
  </xsl:when>
  <xsl:otherwise>
   <xsl:value-of select="$text"/>
  </xsl:otherwise>
 </xsl:choose>
</xsl:template>

  <!-- the regexp program removes xmlns:ora="http://www.oracle.com/XSL/Transform/java/", that is a namespace _declaration_, different from a namespace, 
  and it is hard to do that (of course) -->
  <!--
  <xsl:stylesheet version="2.0" 
  xmlns:xsl="http://www.w3.org/1999/XSL/Transform" 
  xmlns:fo="http://www.w3.org/1999/XSL/Format" 
  xmlns:ora="http://www.oracle.com/XSL/Transform/java/" 
  xmlns:xdofo="http://xmlns.oracle.com/oxp/fo/extensions" 
  xmlns:xdoxslt="http://www.oracle.com/XSL/Transform/java/oracle.xdo.template.rtf.XSLTFunctions" 
  xmlns:xdoxliff="urn:oasis:names:tc:xliff:document:1.1" 
  xmlns:xlink="http://www.w3.org/1999/xlink">
-->
<!--<xsl:template match="@xmlns:ora"/> --> <!--nope-->

<!-- the oracle xslt engine has to interpret this namespace to transform I think? so make sure to declare it above in the xsl:stylesheet tag -->
<xsl:template match="//xsl:value-of[@select=''xdoxslt:one($titlevar)'' and @xdofo:field-name=''$titlevar'']" >
    <xsl:copy>
        <xsl:attribute name="select">$titlevar</xsl:attribute>
   </xsl:copy>
</xsl:template>

<!--these are oracle custom tags...-->
<xsl:template match="xdofo:list-styles" />

<!-- remove these custom attributes, fop does not have them -->
<xsl:template match="@xdofo:field-name|@xdofo:tobetranslated|@xdofo:nf-separator|@xdofo:alt|@xdofo:line-spacing|@xdofo:align|@xdofo:table-summary|@xdofo:row-header-count|@xdofo:xliff-note|@xdofo:repeat|@xdofo:ctx|@xdofo:ctx2|@xdofo:tab-stops" />

<!--replace "xdofo:" namespace strings on remaining attributes, with "xsl:", because some of them work -->
<xsl:template match="@xdofo:*">   
        <xsl:attribute name="xsl:{local-name()}">
            <xsl:value-of select="."/>
        </xsl:attribute>    
</xsl:template>        

<!--remove this xdoxslt variable, some kind of context object? -->
<xsl:template match="//xsl:variable[@name=''_XDOXSLTCTX'']" />

<!--remove this Oracle BI version comment ? ok -->
<xsl:template match="comment()[contains(., ''Generated by'')]" />

<!--remove foreign objects-->
<xsl:template match="//fo:instream-foreign-object" />

<!--remove call to a oracle custom function-->
<xsl:template match="//xsl:value-of[@select=''xdoxslt:chkPrcCancel($_XDOXSLTCTX)'']" />

<!--remove xdoxslt:set_variable-->
<xsl:template match="//xsl:value-of[@select=''xdoxslt:set_variable'']" />

<!-- Switch BODY and BEFORE
    fop error: For "fo:simple-page-master", "fo:region-body" must be declared before "fo:region-before"! -->
<xsl:template match="//fo:simple-page-master">
    <xsl:copy>
        <xsl:apply-templates select="@*"/>
        <xsl:apply-templates select="fo:region-body"/>
        <xsl:apply-templates select="fo:region-before"/>
        <xsl:apply-templates select="fo:region-after"/>
    </xsl:copy>
</xsl:template>

<!--remove xdofo custom namespace from tags... -->
<xsl:template match="//xdofo:*">
        <xsl:element name="xsl:{local-name()}">
            <xsl:for-each select="@*">
                <xsl:attribute name="{local-name()}">
                    <xsl:value-of select="."/>
                </xsl:attribute>
            </xsl:for-each>
            <xsl:apply-templates/>
        </xsl:element>
</xsl:template>

<xsl:template match="//xsl:template[@name=''_XDOATTRIBUTESET'']" >
        <xsl:apply-templates />
</xsl:template>

<xsl:template match="//xsl:call-template[@name=''_XDOATTRIBUTESET'']" />

<xsl:template match="//fo:static-content" />

<!--remove other incompatible attributes -->
<xsl:template match="@style-name|@style-id|@font-family-generic|@xml:space" />

<!--RP fix: org.apache.fop.fo.ValidationException: Invalid property encountered on "fo:table-row": xdo-banded-col -->
<!--RP fix: org.apache.fop.fo.ValidationException: Invalid property encountered on "fo:table-row": xdo-banded-row -->
<!--RP fix: org.apache.fop.fo.ValidationException: Invalid property encountered on "fo:table-row": xdo-last-col -->
<xsl:template match="@xdo-banded-row|@xdo-banded-col|@xdo-first-col|@xdo-last-col|@xdo-first-row|@xdo-last-row" />

<!--RP accessibility fix: add language attr to fo:root (program to something else if you do not like en) -->
<xsl:template match="//fo:root">
    <xsl:copy>
        <xsl:attribute name="language">en</xsl:attribute>
        <xsl:apply-templates select="@*|node()" />
    </xsl:copy>
</xsl:template>

<!--RP accessibility meta -->
<xsl:template match="fo:layout-master-set">
    <xsl:copy>
        <xsl:apply-templates select="@*|node()" />
    </xsl:copy>
      <fo:declarations>
        <pdf:catalog xmlns:pdf="http://xmlgraphics.apache.org/fop/extensions/pdf">
          <pdf:dictionary type="normal" key="ViewerPreferences">
            <pdf:boolean key="DisplayDocTitle">true</pdf:boolean>
          </pdf:dictionary>
        </pdf:catalog>
        <x:xmpmeta xmlns:x="adobe:ns:meta/">
          <rdf:RDF xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
            <rdf:Description rdf:about="" xmlns:dc="http://purl.org/dc/elements/1.1/">
              <!-- Dublin Core properties go here -->
              <dc:title>
                <rdf:Alt>
                  <rdf:li xml:lang="x-default">                
                    <xsl:element name="xsl:value-of"><xsl:attribute name="select">$titlevar</xsl:attribute></xsl:element>
                  </rdf:li>
                </rdf:Alt>
              </dc:title>
              <dc:creator>
                <rdf:Seq>
                  <rdf:li>my company</rdf:li>
                </rdf:Seq>
              </dc:creator>
              <dc:description>
                <rdf:Alt>
                  <rdf:li xml:lang="x-default">
                    <xsl:element name="xsl:value-of"><xsl:attribute name="select">$titlevar</xsl:attribute></xsl:element>
                  </rdf:li>
                </rdf:Alt>
              </dc:description>
              <dc:rights>
                <xsl:text>© copyright my company</xsl:text>
              </dc:rights>
            </rdf:Description>

            <rdf:Description rdf:about="" xmlns:xmp="http://ns.adobe.com/xap/1.0/">
              <!-- XMP properties go here -->
              <xmp:CreatorTool>Oracle + FOP</xmp:CreatorTool>
              <xmp:Title>
                    <xsl:element name="xsl:value-of"><xsl:attribute name="select">$titlevar</xsl:attribute></xsl:element>              
              </xmp:Title>
            </rdf:Description>

<rdf:Description xmlns:pdfuaid="http://www.aiim.org/pdfua/ns/id/" rdf:about="">
<pdfuaid:part>1</pdfuaid:part>
</rdf:Description>

         </rdf:RDF>
        </x:xmpmeta>
      </fo:declarations>
</xsl:template>

<!-- replace <xsl:value-of select="xdoxslt:ms_format_date($_XDOXSLTCTX, string(xdoxslt:one($fv2)), &apos;dd-MMM-yyyy&apos;)"/> -->
<xsl:template match="@*[starts-with(.,''xdoxslt:ms_format_date('')]">
    <xsl:attribute name="{name()}">
        <xsl:value-of select="substring-before(substring-after(.,''string(xdoxslt:one(''),'')), '')"/>
    </xsl:attribute>
</xsl:template>


<!--replace ($_XDOXSLTCTX, xdoxslt:one'',''format-number(number'') -->
<xsl:template match="@*[starts-with(.,''xdoxslt:ms_format_number($_XDOXSLTCTX, xdoxslt:one'')]">
<xsl:variable name="replaced-xdoxsl-ms-one">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="."/>
  <xsl:with-param name="replace"><![CDATA[xdoxslt:ms_format_number($_XDOXSLTCTX, xdoxslt:one]]></xsl:with-param>
  <xsl:with-param name="with">format-number(number</xsl:with-param>
 </xsl:call-template>
</xsl:variable>
<xsl:attribute name="select"><xsl:value-of select="$replaced-xdoxsl-ms-one" /></xsl:attribute>
</xsl:template>

<!--replace ($_XDOXSLTCTX, xdoxslt:number'',''format-number(number'') -->
<xsl:template match="@*[starts-with(.,''xdoxslt:ms_format_number($_XDOXSLTCTX, xdoxslt:number'')]">
<xsl:variable name="replaced-xdoxsl-ms-number">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="."/>
  <xsl:with-param name="replace"><![CDATA[xdoxslt:ms_format_number($_XDOXSLTCTX, xdoxslt:number]]></xsl:with-param>
  <xsl:with-param name="with">format-number(number</xsl:with-param>
 </xsl:call-template>
</xsl:variable>
<xsl:attribute name="select"><xsl:value-of select="$replaced-xdoxsl-ms-number" /></xsl:attribute>
</xsl:template>

</xsl:stylesheet>
';


SELECT
    XMLSERIALIZE(DOCUMENT    
        xmltransform(xmltype(xml_in),xmltype(l_xslfo)
    -- adding encoding string this way is a trick, might break
    )as CLOB VERSION '1.0" encoding="UTF-8' indent size=2 )
into l_xml_out
from dual;


if (fix_urlencode != 'no') then

l_xsl_urlencodefix := '
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xmlns:xdofo="http://xmlns.oracle.com/oxp/fo/extensions" 
 xmlns:fo="http://www.w3.org/1999/XSL/Format" 
 xmlns:ora="http://www.oracle.com/XSL/Transform/java/" 
 xmlns:xdoxslt="http://www.oracle.com/XSL/Transform/java/oracle.xdo.template.rtf.XSLTFunctions" 
>
    
<!-- identity transform, which copies everything forward -->
<xsl:template match="@*|node()">
  <xsl:copy>
    <xsl:apply-templates select="@*|node()"/>
  </xsl:copy>
</xsl:template>

<!--XSLT 1.0 does not have a replace function -->
<xsl:template name="replace-string">
 <xsl:param name="text"/>
 <xsl:param name="replace"/>
 <xsl:param name="with"/>
 <xsl:choose>
  <xsl:when test="$replace and contains($text,$replace)">
   <xsl:value-of select="substring-before($text,$replace)"/>
   <xsl:value-of select="$with"/>
   <xsl:call-template name="replace-string">
    <xsl:with-param name="text" select="substring-after($text,$replace)"/>
    <xsl:with-param name="replace" select="$replace"/>
    <xsl:with-param name="with" select="$with"/>
   </xsl:call-template>
  </xsl:when>
  <xsl:otherwise>
   <xsl:value-of select="$text"/>
  </xsl:otherwise>
 </xsl:choose>
</xsl:template>

<xsl:template match="text()">
  
<xsl:variable name="replaced-percnt">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="."/>
  <xsl:with-param name="replace"><![CDATA[%]]></xsl:with-param>
  <xsl:with-param name="with">%25</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="replaced-plus">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$replaced-percnt"/>
  <xsl:with-param name="replace"><![CDATA[+]]></xsl:with-param>
  <xsl:with-param name="with">%2B</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="replaced-apos">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$replaced-plus"/>
  <xsl:with-param name="replace"><![CDATA['']]></xsl:with-param>
  <xsl:with-param name="with">%26apos;</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="replaced-quot">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$replaced-apos"/>
  <xsl:with-param name="replace"><![CDATA["]]></xsl:with-param>
  <xsl:with-param name="with">%26quot;</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="replaced-amp">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$replaced-quot"/>
  <xsl:with-param name="replace"><![CDATA[&]]></xsl:with-param>
  <xsl:with-param name="with">%26amp;</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="replaced-lt">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$replaced-amp"/>
  <xsl:with-param name="replace"><![CDATA[<]]></xsl:with-param>
  <xsl:with-param name="with">%26lt;</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="replaced-gt">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$replaced-lt"/>
  <xsl:with-param name="replace"><![CDATA[>]]></xsl:with-param>
  <xsl:with-param name="with">%26gt;</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<!-- Output --> 
<xsl:value-of select="$replaced-gt" />
</xsl:template>

<xsl:template match="@*">
  
<xsl:variable name="areplaced-percnt">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="."/>
  <xsl:with-param name="replace"><![CDATA[%]]></xsl:with-param>
  <xsl:with-param name="with">%25</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="areplaced-plus">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$areplaced-percnt"/>
  <xsl:with-param name="replace"><![CDATA[+]]></xsl:with-param>
  <xsl:with-param name="with">%2B</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="areplaced-apos">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$areplaced-plus"/>
  <xsl:with-param name="replace"><![CDATA['']]></xsl:with-param>
  <xsl:with-param name="with">%26apos;</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="areplaced-quot">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$areplaced-apos"/>
  <xsl:with-param name="replace"><![CDATA["]]></xsl:with-param>
  <xsl:with-param name="with">%26quot;</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="areplaced-amp">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$areplaced-quot"/>
  <xsl:with-param name="replace"><![CDATA[&]]></xsl:with-param>
  <xsl:with-param name="with">%26amp;</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="areplaced-lt">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$areplaced-amp"/>
  <xsl:with-param name="replace"><![CDATA[<]]></xsl:with-param>
  <xsl:with-param name="with">%26lt;</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<xsl:variable name="areplaced-gt">
 <xsl:call-template name="replace-string">
  <xsl:with-param name="text" select="$areplaced-lt"/>
  <xsl:with-param name="replace"><![CDATA[>]]></xsl:with-param>
  <xsl:with-param name="with">%26gt;</xsl:with-param>
 </xsl:call-template>
</xsl:variable>

<!-- Output --> 
<xsl:attribute name="{name()}">
<xsl:value-of select="$areplaced-gt" />
</xsl:attribute>
</xsl:template>

</xsl:stylesheet>
';

SELECT
    XMLSERIALIZE(DOCUMENT    
        xmltransform(xmltype(l_xml_out),xmltype(l_xsl_urlencodefix)
    -- adding encoding string this way is a trick, might break
    )as CLOB VERSION '1.0" encoding="UTF-8' indent size=2 )
into l_xml_out
from dual;
end if;

--not this...return DBMS_XMLGEN.CONVERT(l_xml_out);
--not this...return utl_url.escape(l_xml_out);
return l_xml_out;
end;


function clob2blob(AClob CLOB) return BLOB is
  Result BLOB;
  o1 integer;
  o2 integer;
  c integer;
  w integer;
begin
  o1 := 1;
  o2 := 1;
  c := 0;
  w := 0;
  DBMS_LOB.CreateTemporary(Result, true);
  DBMS_LOB.ConvertToBlob(Result, AClob, length(AClob), o1, o2, 0, c, w);
  return(Result);
end clob2blob;

FUNCTION blob2clob (i_blob IN BLOB) RETURN CLOB AS
    o_clob CLOB;
    i_dest_offset PLS_INTEGER := 1;
    i_src_offset PLS_INTEGER := 1;
    i_lang_context PLS_INTEGER := DBMS_LOB.DEFAULT_LANG_CTX;
    i_Warning PLS_INTEGER;
BEGIN
  IF i_blob IS NOT NULL THEN
   IF LENGTH(i_blob) = 0 THEN
     RETURN EMPTY_CLOB();
   END IF;
   DBMS_LOB.createTemporary(lob_loc => o_clob,
     cache => TRUE); -- read into buffer cache
   DBMS_LOB.CONVERTTOCLOB(
     dest_lob => o_clob,
     src_blob => i_blob,
     amount => DBMS_LOB.LOBMAXSIZE,
     dest_offset => i_dest_Offset,
     src_offset => i_src_Offset,
     blob_csid => DBMS_LOB.DEFAULT_CSID,
     lang_context => i_lang_context,
     warning => i_Warning
   );
   ELSE
    o_clob := NULL;
   END IF;
   RETURN o_Clob;
  EXCEPTION
    WHEN OTHERS THEN RAISE;
  END blob2clob;


-- -------------------------------------------------------------- 
-- Pavel Glebov - Creation
-- P. Monaco - Adding more filters
--Roger Pilkey - adding even more filters 2020-06
-- --------------------------------------------------------------
procedure convert_fo_template(p in out nocopy clob)   
 is
   --v_region_before  varchar2(32000);
   --v_region_body    varchar2(32000);
   --v_region_after   varchar2(32000);
   v_region_before  clob;
   v_region_body    clob;
   v_region_after   clob;
 begin
    -- tested with Oracle BI Publisher Desktop 12.2.1.2.0 Build 12.212.00.0

    -- del incompatible strings
    p:= replace(p,'<xsl:variable name="_XDOXSLTCTX" select="xdoxslt:set_xslt_locale($_XDOCTX, $_XDOLOCALE, $_XDOTIMEZONE, $_XDOCALENDAR, $_XDODFOVERRIDE, $_XDOCURMASKS, $_XDONFSEPARATORS)"/>','');
    p := regexp_replace(p,'<!--Generated by[^>]+>','');
    p := regexp_replace(p,'xmlns:ora=[^>]+/"','');
    p := regexp_replace(p,'xmlns:xdofo[^>]+/"','');
    -- convert foreign objects into static images
    -- the task is managed in a very limited way !
    -- remove all foreign objects
   p := regexp_replace(p,'<fo:instream-foreign-object [^<]*</fo:instream-foreign-object>','');
    -- p := regexp_replace(p,'<fo:instream-foreign-object [^>]+>','<fo:external-graphic  width="167.55pt" height="147.35pt" content-width="scale-to-fit"  src="url(''data:image/png;base64,');
   -- p := regexp_replace(p,'<fo:instream-foreign-object [^>]+>','<fo:external-graphic  width="167.55pt" height="147.35pt" content-width="scale-to-fit"  src="url(''data:image/png;base64,');

    --p := replace(p,'</fo:instream-foreign-object>',''')"/>');

    -- p:= replace(p,'xmlns:xdofo="http://xmlns.oracle.com/oxp/fo/extensions"','');
    -- p:= replace(p,'xmlns:xdoxslt="http://www.oracle.com/XSL/Transform/java/oracle.xdo.template.rtf.XSLTFunctions"','');
    p:= replace(p,'xmlns:xdoxliff="urn:oasis:names:tc:xliff:document:1.1"','');
    -- p:= replace(p,'_XDO','_FOP');
    p := replace(p, '<xsl:value-of select="xdoxslt:chkPrcCancel($_XDOXSLTCTX)"/>','');
    p:= replace(p,'<fo:title>','');
    p:= replace(p,'<xsl:value-of select="xdoxslt:one($titlevar)" xdofo:field-name="$titlevar"/>','');
    p:= replace(p,'</fo:title>','');
    p := regexp_replace(p,'<xsl:variable name="titlevar"[^>]+/>','');
    -- Add a enclosing block after a fo:flow  / no more needed with saxon parser

    --p := regexp_replace(p,'<fo:flow flow-name="[^>]+/>','');
    -- <fo:flow flow-name="region-body">
    --p:= replace(p,'</fo:flow>','</fo:block></fo:flow>');

    -- formatting
    p := replace(p,'xdoxslt:ms_format_number($_XDOXSLTCTX, xdoxslt:one','format-number(number');
    p := replace(p,'xdoxslt:ms_format_number($_XDOXSLTCTX, xdoxslt:number','format-number(number');

    -- Remove all others variable settings
    p := regexp_replace(p,'<xsl:value-of select="xdoxslt:set_variable[^>]','');
    p:= replace(p,'xdoxslt:one','number');
    -- del  xdofo: attributes
    -- <fo:root xdofo:nf-separator="{$_XDONFSEPARATORS}"> => <fo:root >    
    p := regexp_replace(p,'xdofo:(\w|[-])+="[^"]+"','');
    -- del xdofo: open and close tags
    -- <xdofo:property name="default-tab-width">35.4pt</xdofo:property> => NULL
    p := regexp_replace(p,'<xdofo:[^/]+/xdofo:(\w|[-])+>','');
    -- del standalone xdofo: tags
    -- <xdofo:properties> = > NULL
    p := regexp_replace(p,'</?xdofo:(\w|[-])+>','');
    --del empty <fo:static-content/>
    p := regexp_replace(p,'<fo:static-content[^>]+/>','');

    --remove other incompatible attributes
    p := regexp_replace(p,'style\-name="[^"]+"','');
    p := regexp_replace(p,'font\-family\-generic="[^"]+"','');
    p := regexp_replace(p,'style\-id="[^"]+"','');
    p := regexp_replace(p,'xml:space="[^"]+"','');

   -- Switch BODY and BEFORE
   -- In XSLT 1 and 2?,  "body" must be after "before"
    /*
               <fo:region-before region-name="region-header" extent="35.45pt"/>
               <fo:region-body region-name="region-body" margin-top="35.45pt" margin-bottom="21.3pt"/>
               <fo:region-after region-name="region-footer" extent="21.3pt" display-align="after"/>
         =>
               <fo:region-body region-name="region-body" margin-top="35.45pt" margin-bottom="21.3pt"/>
               <fo:region-before region-name="region-header" extent="35.45pt"/>               
               <fo:region-after region-name="region-footer" extent="21.3pt" display-align="after"/>
   */   
   v_region_before  := regexp_substr(p,'<fo:region\-before .+/>');
   v_region_body    := regexp_substr(p,'<fo:region\-body .+/>');
   v_region_after   := regexp_substr(p,'<fo:region\-after .+/>');
   p := replace(p,v_region_before,'');
   p := replace(p,v_region_body,'');
   p := replace(p,v_region_after,v_region_body||v_region_before||v_region_after);

   --remove empty rows
   p := regexp_replace(p,'<fo:table-row>[^<]*<fo:table-cell [^/]*/>[^<]*</fo:table-row>','');  

   --RP fix: org.apache.fop.fo.ValidationException: Invalid property encountered on "fo:table-row": xdo-banded-col 
   p := regexp_replace(p,'xdo-banded-col="[^"]+"','');

   --RP fix: org.apache.fop.fo.ValidationException: Invalid property encountered on "fo:table-row": xdo-banded-row
   p := regexp_replace(p,'xdo-banded-row="[^"]+"','');

   --RP fix: org.apache.fop.fo.ValidationException: Invalid property encountered on "fo:table-row": xdo-last-col
    p := regexp_replace(p,'xdo-last-col="[^"]+"','');   
    p := regexp_replace(p,'xdo-first-col="[^"]+"',''); 
    p := regexp_replace(p,'xdo-last-row="[^"]+"','');   
    p := regexp_replace(p,'xdo-first-row="[^"]+"',''); 

   --RP fix:            <xdofo:list-template template-id="1322736315"> has no end tag, just end here to validate, not sure what it is good for
   p := regexp_replace(p,'<xdofo:list-template template-id="(\d*)">','<xdofo:list-template template-id="\1" />');

   --RP fix: xml tag should use quote, not apostrophe
   p := regexp_replace(p,'<\?xml version = ''1.0'' encoding = ''utf-8''\?>','<?xml version="1.0" encoding="utf-8"?>');

   --RP fix:
   --replace (some?) xml special characters because APEX_UTIL.DOWNLOAD_PRINT_DOCUMENT sends to FOP with urlencode, which breaks on these unencoded chars?
   --most are only necessary when this was a CLOB, now that it's an XMLTYPE, these are automatically converted, I think
   
   --RP for Report Query and Report layout, "fix" just these three encodings?
   --p := regexp_replace(p,'%','%25');  
   --p := regexp_replace(p,'\+','%2b'); 
   --p := regexp_replace(p,'&','%26');
   
   --But for sending to download_print_document with all of our replace_string calls like NMS, don't do that?
   
   -- RP other character encodings I tried:
   
   --p := regexp_replace(p,'%','%25');  
   --p := regexp_replace(p,'\+','%2b'); 
   --p := regexp_replace(p,'''','%26apos;');
   --p := regexp_replace(p,'&amp;','%26amp;');
   --p := regexp_replace(p,'"','%26quot;');
   --p := regexp_replace(p,'<','%26lt;');   
   --p := regexp_replace(p,'>','%26gt;');   

 end convert_fo_template;

end "BIP2FOP_PKG";
/
